                // TEST WEKA LOGISTIC REGRESSION
                /*
                String iris = "source\\Python\\DV_data.csv";
                CSVLoader csv = new CSVLoader();
                csv.setSource(new File(iris));

                Instances data = csv.getDataSet();
                data.setClassIndex(data.numAttributes() - 1);
                Evaluation eval = new Evaluation(data);
                Logistic lg = new Logistic();
                lg.buildClassifier(data);
                eval.evaluateModel(lg, data);

                double[][] coefs = lg.coefficients();
                double max = -Double.MAX_VALUE;

                for (int i = 1; i <= DV.fieldLength; i++)
                {
                    if (max < Math.abs(coefs[i][0]))
                        max = Math.abs(coefs[i][0]);
                }

                for (int i = 1; i <= DV.fieldLength; i++)
                {
                    coefs[i][0] /= max;
                }

                for (int i = 1; i <= DV.fieldLength; i++)
                {
                    coefs[i][0] = Math.acos(coefs[i][0]);
                    coefs[i][0] = Math.toDegrees(coefs[i][0]);
                }

                //eval.crossValidateModel(lg, data, 5, new Random(100));
                System.out.println(eval.toMatrixString());
                System.out.println(eval.toSummaryString());
                System.out.println(eval.pctCorrect());
                System.out.println(Arrays.deepToString(lg.coefficients()));
                 */


    /**
     * Draws regression graphs for specified visualization*
     */
    public static void drawReg() throws FileNotFoundException {
        try
        {
            // create csv file
            File csv = new File("D:\\GitHub\\DV\\datasets\\DV_data.csv");
            Files.deleteIfExists(csv.toPath());

            // write to csv file
            PrintWriter out = new PrintWriter(csv);

            // create header for file
            for (int i = 0; i < DV.fieldLength; i++)
            {
                if (i != DV.fieldLength - 1)
                    out.print("feature,");
                else
                    out.print("feature\n");
            }

            // check all classes
            for (int i = 0; i < DV.data.size(); i++)
            {
                // get all data for class
                for (int j = 0; j < DV.data.get(i).data.length; j++)
                {
                    for (int k = 0; k < DV.fieldLength; k++)
                    {
                        if (k != DV.fieldLength - 1)
                            out.printf("%f,", DV.data.get(i).data[j][k]);
                        else
                            out.printf("%f" + "\n", DV.data.get(i).data[j][k]);
                    }
                }
            }

            // close file
            out.close();
        }
        catch (IOException ioe)
        {
            ioe.printStackTrace();
        }

        System.exit(0);

        String[][] outputData;

        File datafile = new File("C:\\Users\\Administrator\\GitHub\\DV\\datasets\\regression_info.csv");
        try (Scanner fileReader = new Scanner(datafile))
        {
            ArrayList<String> rowData = new ArrayList<>();

            // put rows of data into arraylist
            while(fileReader.hasNextLine())
                rowData.add(fileReader.nextLine());

            ArrayList<String[]> data = new ArrayList<>();

            // split rows by ","
            for (String rowDatum : rowData)
            {
                String[] tmp = rowDatum.split(",");

                // only add if there is data
                if (tmp.length > 0)
                    data.add(tmp);
            }

            // arraylist to array
            outputData = new String[data.size()][];
            outputData = data.toArray(outputData);
        }
        DV.fieldLength = outputData[0].length;
        DV.angles = new double[outputData[0].length];

        for (int i = 0; i < outputData[0].length; i++)
        {
            DV.angles[i] = Double.parseDouble(outputData[0][i]);
        }

        double intercept = Double.parseDouble(outputData[1][0]);

        double div = Double.parseDouble(outputData[2][0]);

        double[] orig = new double[DV.data.get(0).data.length];

        for (int i = 0; i < DV.data.get(0).data.length; i++)
        {
            double[] old = new double[DV.fieldLength];

            for (int j = 0; j < DV.fieldLength; j++)
            {
                old[j] = DV.data.get(0).data[i][j];
            }
            orig[i] = DV.data.get(0).data[i][DV.fieldLength];

            DV.data.get(0).data[i] = old;
        }

        // remove old graphs
        GRAPHS.clear();

        // remove old graphs
        DV.graphPanel.removeAll();

        // holds classes to be graphed
        ArrayList<DataObject> upperObjects = new ArrayList<>(List.of(DV.data.get(0)));

        // calculate coordinates
        double upperScaler = getCoordinates(upperObjects);

        // get max point frequency
        double maxFrequency = 7;//getMaxFrequency();

        // get scaler
        double graphScaler = Math.max(upperScaler, 1);

        // add upper graph
        AddRegGraph upperGraph = new AddRegGraph(upperObjects, orig, 0, graphScaler, maxFrequency, div);
        upperGraph.execute();

        // wait for threads to finish
        try
        {
            // graph threads
            upperGraph.get();
        }
        catch (ExecutionException | InterruptedException e)
        {
            e.printStackTrace();
            return;
        }

        GridBagConstraints gpc = new GridBagConstraints();
        gpc.gridx = 0;
        gpc.gridy = 0;
        gpc.weightx = 1;
        gpc.weighty = 1;
        gpc.fill = GridBagConstraints.BOTH;

        CombinedDomainXYPlot plot = new CombinedDomainXYPlot();
        plot.setOrientation(PlotOrientation.VERTICAL);
        plot.setGap(0);
        plot.getDomainAxis().setVisible(false);
        plot.setOutlinePaint(null);
        plot.setOutlineVisible(false);
        plot.setInsets(RectangleInsets.ZERO_INSETS);
        plot.setDomainPannable(true);
        plot.setRangePannable(true);
        plot.setBackgroundPaint(DV.background);
        plot.setDomainGridlinePaint(Color.GRAY);
        plot.setRangeGridlinePaint(Color.GRAY);

        JFreeChart chart = new JFreeChart("", null, plot, false);

        // add graphs in order
        for (int i = 0; i < GRAPHS.size(); i++)
        {
            if (GRAPHS.containsKey(i))
            {
                plot.add((XYPlot) GRAPHS.get(i).getPlot(), 1);

                if (DV.displayRemoteGraphs)
                    DV.remoteGraphPanel.add(REMOTE_GRAPHS.get(i), gpc);
            }
        }

        ChartPanel chartPanel = new ChartPanel(chart);
        chartPanel.setMouseWheelEnabled(true);

        DV.graphPanel.add(chartPanel, gpc);

        // revalidate graphs and confusion matrices
        DV.graphPanel.repaint();
        DV.graphPanel.revalidate();;
    }


    private static class AddRegGraph extends SwingWorker<Boolean, Void>
    {
        final ArrayList<DataObject> DATA_OBJECTS;
        final int UPPER_OR_LOWER;
        final double GRAPH_SCALER;
        final double MAX_FREQUENCY;
        final double[] PREDS;
        final double INTERCEPT;

        /**
         * Initializes parameters
         * @param dataObjects classes to draw
         * @param upperOrLower draw up when upper (0) and down when lower (1)
         * @param graphScaler how much to zoom out the graphs
         */
        AddRegGraph(ArrayList<DataObject> dataObjects, double[] preds, int upperOrLower, double graphScaler, double maxFrequency, double intercept)
        {
            this.DATA_OBJECTS = dataObjects;
            this.UPPER_OR_LOWER = upperOrLower;
            this.GRAPH_SCALER = graphScaler;
            this.MAX_FREQUENCY = maxFrequency;
            this.PREDS = preds;
            this.INTERCEPT = intercept;
        }
        @Override
        protected Boolean doInBackground()
        {
            // create main renderer and dataset
            XYLineAndShapeRenderer lineRenderer = new XYLineAndShapeRenderer(true, false);
            XYSeriesCollection graphLines = new XYSeriesCollection();

            // renderer for endpoint, midpoint, and timeline
            XYLineAndShapeRenderer endpointRenderer = new XYLineAndShapeRenderer(false, true);
            XYLineAndShapeRenderer midpointRenderer = new XYLineAndShapeRenderer(false, true);
            XYLineAndShapeRenderer timeLineRenderer = new XYLineAndShapeRenderer(false, true);
            XYSeriesCollection endpoints = new XYSeriesCollection();
            XYSeriesCollection midpoints = new XYSeriesCollection();
            XYSeriesCollection timeLine = new XYSeriesCollection();
            XYSeries midpointSeries = new XYSeries(0, false, true);
            XYSeries timeLineSeries = new XYSeries(0, false, true);

            XYLineAndShapeRenderer predRenderer = new XYLineAndShapeRenderer(false, true);
            XYSeriesCollection preds = new XYSeriesCollection();
            XYSeries predSeries = new XYSeries(0, false, true);

            for (int i = 0; i < PREDS.length; i++)
            {
                //predSeries.add(DV.data.get(0).coordinates[i][1][0], 0);
            }

            XYLineAndShapeRenderer realRenderer = new XYLineAndShapeRenderer(false, true);
            XYSeriesCollection reals = new XYSeriesCollection();
            XYSeries realSeries = new XYSeries(0, false, true);

            for (int i = 0; i < DV.data.get(0).data.length; i++)
            {
                //realSeries.add(DV.data.get(0).coordinates[i][1][0], -Math.abs(DV.data.get(0).coordinates[i][1][0] - PREDS[i]));
            }

            double tmpBound = GRAPH_SCALER * DV.fieldLength;
            double fullBound = tmpBound * 2;
            double spacing = fullBound / PREDS.length;
            tmpBound = -tmpBound;

            double buffer = DV.fieldLength / 10.0;

            // populate main series
            int lineCnt = -1;

            for (DataObject data : DATA_OBJECTS)
            {
                for (int i = 0; i < data.data.length; i++)
                {
                    double endpoint = data.coordinates[i][data.coordinates[i].length - 1][0];

                    // ensure datapoint is within domain
                    // if drawing overlap, ensure datapoint is within overlap
                    if (true)
                    {
                        int upOrDown = UPPER_OR_LOWER == 1 ? -1 : 1;

                        // start line at (0, 0)
                        XYSeries line = new XYSeries(++lineCnt, false, true);
                        XYSeries endpointSeries = new XYSeries(lineCnt, false, true);

                        if (DV.showFirstSeg)
                            line.add(0, upOrDown * buffer);

                        // add points to lines
                        for (int j = 0; j < data.coordinates[i].length - 1; j++)
                        {
                            line.add(data.coordinates[i][j][0], upOrDown * (data.coordinates[i][j][1] + buffer));

                            // add endpoint and timeline
                            if (j == data.coordinates[i].length - 2)
                            {
                                endpointSeries.add(data.coordinates[i][j][0], upOrDown * (data.coordinates[i][j][1] + buffer));
                                //timeLineSeries.add(data.coordinates[i][j][0], 0);
                                timeLineSeries.add((PREDS[i] / INTERCEPT), 0);
                                realSeries.add((PREDS[i] / INTERCEPT), 0 - Math.abs((PREDS[i] / INTERCEPT) - data.coordinates[i][j][0]));
                                System.out.println("Original: " + PREDS[i]);
                                System.out.println("Altered: " + (PREDS[i] / INTERCEPT));
                                System.out.println("Prediction: " + data.coordinates[i][j][0]);
                                System.out.println("Difference: " + Math.abs((PREDS[i] / INTERCEPT) - data.coordinates[i][j][0]) + "\n");
                                tmpBound += spacing;

                                graphLines.addSeries(line);
                                endpoints.addSeries(endpointSeries);

                                if (DV.highlights[UPPER_OR_LOWER][i])
                                    lineRenderer.setSeriesPaint(lineCnt, Color.ORANGE);
                                else
                                    lineRenderer.setSeriesPaint(lineCnt, DV.graphColors[UPPER_OR_LOWER]);

                                // check if endpoint is correctly classified
                                endpointRenderer.setSeriesPaint(lineCnt, Color.BLACK);//DV.graphColors[1])
                                endpointRenderer.setSeriesShape(lineCnt, new Ellipse2D.Double(-1, -1, 2, 2));
                            }
                        }
                    }
                }
            }

            // add data to series
            //endpoints.addSeries(endpointSeries);
            midpoints.addSeries(midpointSeries);
            timeLine.addSeries(timeLineSeries);
            preds.addSeries(predSeries);
            reals.addSeries(realSeries);

            JFreeChart chart = ChartFactory.createXYLineChart(
                    "",
                    "",
                    "",
                    graphLines,
                    PlotOrientation.VERTICAL,
                    false,
                    true,
                    false);

            // format chart
            chart.setBorderVisible(false);
            chart.setPadding(RectangleInsets.ZERO_INSETS);

            // get plot
            XYPlot plot = (XYPlot) chart.getPlot();

            // format plot
            plot.setDrawingSupplier(new DefaultDrawingSupplier(
                    new Paint[] { DV.graphColors[UPPER_OR_LOWER] },
                    DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE,
                    DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE,
                    DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE,
                    DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));
            plot.getRangeAxis().setVisible(false);
            plot.getDomainAxis().setVisible(false);
            plot.setOutlinePaint(null);
            plot.setOutlineVisible(false);
            plot.setInsets(RectangleInsets.ZERO_INSETS);
            plot.setDomainPannable(true);
            plot.setRangePannable(true);
            plot.setBackgroundPaint(DV.background);
            plot.setDomainGridlinePaint(Color.GRAY);
            plot.setRangeGridlinePaint(Color.GRAY);
            plot.setSeriesRenderingOrder(SeriesRenderingOrder.REVERSE);
            //System.out.println(plot.getSeriesRenderingOrder());

            // set domain and range of graph
            double bound = GRAPH_SCALER * DV.fieldLength;

            // set domain
            ValueAxis domainView = plot.getDomainAxis();
            domainView.setRange(-bound, bound);
            NumberAxis xAxis = (NumberAxis) plot.getDomainAxis();
            xAxis.setTickUnit(new NumberTickUnit(buffer));

            // set range
            ValueAxis rangeView = plot.getRangeAxis();
            NumberAxis yAxis = (NumberAxis) plot.getRangeAxis();
            yAxis.setTickUnit(new NumberTickUnit(buffer));

            // set range up or down
            if (UPPER_OR_LOWER == 1)
                rangeView.setRange(-bound * (DV.mainPanel.getHeight() * 0.7) / (DV.graphPanel.getWidth() * 0.8), 0);
            else
                rangeView.setRange(0, bound * (DV.mainPanel.getHeight() * 0.7) / (DV.graphPanel.getWidth() * 0.8));

            // renderer for bars
            XYIntervalSeriesCollection bars = new XYIntervalSeriesCollection();
            XYBarRenderer barRenderer = new XYBarRenderer();

            // create bar chart
            if (DV.showBars)
            {
                int[] barRanges = new int[400];

                // get bar lengths
                for (DataObject dataObj : DATA_OBJECTS)
                {
                    // translate endpoint to slider ticks
                    // increment bar which endpoint lands
                    for (int i = 0; i < dataObj.data.length; i++)
                    {
                        int tmpTick = (int) (Math.round((dataObj.coordinates[i][DV.fieldLength-1][0] / DV.fieldLength * 200) + 200));
                        barRanges[tmpTick]++;
                    }
                }

                // get interval and bounds
                double interval = DV.fieldLength / 200.0;
                double maxBound = -DV.fieldLength;
                double minBound = -DV.fieldLength;

                // add series to collection
                for (int i = 0; i < 400; i++)
                {
                    // get max bound
                    maxBound += interval;

                    XYIntervalSeries bar = new XYIntervalSeries(i, false, true);

                    // bar width = interval
                    // bar height = (total endpoints on bar) / (total endpoints)
                    // buffer = maximum bar height
                    if (UPPER_OR_LOWER == 1)
                        bar.add(interval, minBound, maxBound, (-barRanges[i] / MAX_FREQUENCY) * buffer, -buffer, 0);
                    else
                        bar.add(interval, minBound, maxBound, (barRanges[i] / MAX_FREQUENCY) * buffer, 0, buffer);

                    bars.addSeries(bar);
                    barRenderer.setSeriesPaint(i, DV.graphColors[UPPER_OR_LOWER]);

                    // set min bound to old max
                    minBound = maxBound;
                }
            }

            // set endpoint renderer and dataset
            plot.setRenderer(0, endpointRenderer);
            plot.setDataset(0, endpoints);


            // set midpoint renderer and dataset
            midpointRenderer.setSeriesShape(0, new Ellipse2D.Double(-0.5, -0.5, 1, 1));
            midpointRenderer.setSeriesPaint(0, DV.endpoints);
            plot.setRenderer(1, midpointRenderer);
            plot.setDataset(1, midpoints);
            // set line renderer and dataset
            lineRenderer.setBaseStroke(new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));
            lineRenderer.setAutoPopulateSeriesStroke(false);
            plot.setRenderer(2, lineRenderer);
            plot.setDataset(2, graphLines);

            // set bar or timeline renderer and dataset
            if (DV.showBars)
            {
                barRenderer.setSeriesPaint(0, DV.graphColors[UPPER_OR_LOWER]);
                barRenderer.setShadowVisible(false);
                plot.setRenderer(3, barRenderer);
                plot.setDataset(3, bars);
            }
            else
            {
                if (UPPER_OR_LOWER == 1)
                    timeLineRenderer.setSeriesShape(0, new Rectangle2D.Double(-0.25, 0, 0.5, 3));
                else
                    timeLineRenderer.setSeriesShape(0, new Rectangle2D.Double(-0.25, -3, 0.5, 3));

                timeLineRenderer.setSeriesPaint(0, DV.graphColors[UPPER_OR_LOWER]);
                plot.setRenderer(3, timeLineRenderer);
                plot.setDataset(3, timeLine);
            }

            // set midpoint renderer and dataset
            predRenderer.setSeriesShape(0, new Rectangle2D.Double(-0.25, 0, 0.5, 3));
            predRenderer.setSeriesPaint(0, Color.BLUE);
            plot.setRenderer(4, predRenderer);
            plot.setDataset(4, preds);

            // set midpoint renderer and dataset
            realRenderer.setSeriesShape(0, new Rectangle2D.Double(-0.25, 0, 0.5, 3));
            realRenderer.setSeriesPaint(0, Color.GREEN);
            plot.setRenderer(5, realRenderer);
            plot.setDataset(5, reals);

            // add graph to graph panel
            synchronized (GRAPHS)
            {
                GRAPHS.put(UPPER_OR_LOWER, chart);
            }
            return true;
        }
    }